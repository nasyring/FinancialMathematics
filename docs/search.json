[{"path":"index.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"","code":""},{"path":"intro.html","id":"intro","chapter":"2 Introduction","heading":"2 Introduction","text":"","code":""},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation","chapter":"3 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"3 The geometric Brownian motion model of asset value and Monte Carlo simulation","text":"","code":""},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"asset-values-as-random-variables","chapter":"3 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"3.1 Asset values as random variables","text":"Let \\(\\{S_t, t\\geq 0\\}\\) denote values asset times \\(t\\). Ideally, think time continuum, \\(S_t\\) continuous process. Practically, however, approximate continuous process discrete one performing computations associated process grid \\(t\\) values interval \\([0,T]\\) mesh-size \\(\\Delta t\\).model process \\(S_t\\) random stochastic sequence; essentially, just sequence realizations random variables.plot Apple’s (AAPL) close--day stock price logarithm return \\(\\log(S_t/S_{t-1})\\) initial listing present day. Stock prices available much often daily, data visualized already represent discretization underlying process (mesh-size 1 day).","code":"import numpy as np\nimport numpy.random as npr\nimport matplotlib as mpl\nfrom matplotlib.pylab import plt \nimport math\n\nplt.style.use('seaborn')\nmpl.rcParams['font.family'] = 'serif'\n\nimport pandas as pd\nimport yfinance as yf\nfrom yahoofinancials import YahooFinancials\n\naapl_df = yf.download('AAPL')## \n[*********************100%***********************]  1 of 1 completedclose_price = aapl_df['Adj Close']\nlog_rets = np.log(close_price / close_price.shift(1))\naapl_df['log_rets'] = log_rets\naapl_df[['Adj Close', 'log_rets']].plot(subplots=True, figsize=(10, 6))## array([<AxesSubplot:xlabel='Date'>, <AxesSubplot:xlabel='Date'>],\n##       dtype=object)plt.show();"},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"geometric-brownian-motion-model-of-asset-prices-over-time","chapter":"3 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"3.2 Geometric Brownian motion model of asset prices over time","text":"mathematics continuous stochastic processes advanced. Rather presenting full account focus intermediate level understanding one common models used asset prices. Later modify model account several real-life phenomena.folk-wisdom log returns asset \\(\\log\\frac{S_t}{S_{t-1}}\\) normally-distributed, , rather, modeled . comes consequence modeling sequence asset prices geometric Brownian motion.Brownian motion (also called Wiener process) essentially sequence normal random variables. Specifically, process \\(W_t\\) satisfies\n- \\(W_0 = 0\\)\n- \\(W_t\\) continuous .s.\n- \\(W_t\\) independent increments\n- \\(W_t - W_s \\sim N(0,t-s)\\) \\(0\\leq s\\leq t\\)\nAdditionally, sequence measurable respect filtration, ordered family sigma-fields (details see, example, Resnick’s Probability Path Chapter 10).geometric Brownian motion (gBm) model says changes asset price time \\(t\\) time \\(t+s\\) determined Brownian motion drift. typically written following fashion stochastic differential equation (SDE) respect instantaneous price change:\n\\[dS_t = rS_tdt + \\sigma S_t dW_t\\]\n\\(r\\) risk-free interest rate, \\(dt\\) instantaneous change time, \\(\\sigma\\) volatility (standard deviation) parameter, \\(W_t\\) Brownian motion.important keep mind SDE doesn’t really mean anything—rather, simply notation used express stochastic integral concise manner. meaningful expression geometric Brownian motion model given difference equation\n\\[S_{t+s} = S_t = \\int_t^{t+s} rS_u\\,du + \\int_{t}^{t+s} \\sigma S_u \\, dW_u.\\]\nprimary challenge overcome define integration respect Brownian motion \\(W_u\\). various technical reasons, integration behave exactly way integration works real-valued functions, .e., Riemann integration. new theory integration, Ito integration, needed.Rather giving thorough treatment Ito’s calculus, simply provide informal derivation Ito’s Lemma, enough provide ``solution” geometric Brownian motion. Let \\(f(t,\\,S_t)\\) function time asset price time \\(t\\). Take two term Taylor expansion \\(f\\) use geometric Brownian motion SDE chain rule follows:\\[\\begin{align*}\ndf &= \\frac{\\partial f}{\\partial t}dt + \\frac{\\partial f}{\\partial S_t}dS_t + \\frac{1}{2}\\frac{\\partial^2 f}{\\partial S_t^2}dS_t^2 + \\cdots\\\\\n& = \\frac{\\partial f}{\\partial t}dt + \\frac{\\partial f}{\\partial S_t}(rS_tdt + \\sigma S_t dW_t) + \\frac{1}{2}\\frac{\\partial^2 f}{\\partial S_t^2}(r^2S_t^2dt^2 + 2r\\sigma S_t^2 dtdW_t + \\sigma^2S_t^2dW_t^2) + \\cdots.\n\\end{align*}\\], Ito’s Lemma says \\(dW_t^2 = O(dt)\\) substitution \\(dW_t^2 = dt\\) justified, terms \\(dt^2\\) \\(dt\\,dW_t\\) ignorable may substituted zero. Taylor expansion simplifies, according Ito, \n\\[df = \\left(\\frac{\\partial f}{\\partial t} + r S_t\\frac{\\partial f}{\\partial S_t} +\\frac{\\sigma^2}{2}S_t^2\\frac{\\partial^2 f}{\\partial S_t^2}\\right)dt + \\sigma\\frac{\\partial f}{\\partial S_t}S_t \\,dW_t.\\]Now, let \\(f(t,\\, S_t):= \\log(S_t)\\), log asset price time \\(t\\). case, following derivatives:\n\\[\\partial f/\\partial t = 0\\quad \\partial f/\\partial S_t = 1/S_t \\quad \\partial^2 f/\\partial S_t^2 = -1/S_t^2.\\]\nSubstituting SDE , get\n\\[d\\log S_t = r\\,dt - \\frac{\\sigma^2}{2S_t^2}S_t^2\\,dt + \\frac{\\sigma}{S_t}S_t\\,dW_t. \\]\nNext integrate sides:\n\\[\\log S_t = \\log(S_0) + \\left(r - \\frac{\\sigma^2}{2}\\right)t + \\sigma\\, W_t.\\]\nExponentiate obtain\\[S_t = S_0\\exp\\left(rt - \\frac{\\sigma^2}{2}t+\\sigma \\, W_t\\right).\\]\nRecall \\(W_t - W_0 := W_t\\) variance \\(t\\) see \\(S_t/S_0\\) log-normally distributed parameters \\((r - \\sigma^2/2)t\\) \\(\\sigma\\, t^{1/2}\\), means right-skewed mean \\(\\exp(rt)\\) variance \\((\\exp(\\sigma^2 t)-1)\\cdot\\exp(2rt)\\).Armed Ito’s Lemma, confirmed folk-wisdom log-returns time \\(t\\) \\(t+s\\) (modeled ) normal random variables mean \\((r - \\frac{\\sigma^2}{2}) s\\) variance \\(\\sigma^2 s\\). One last minor point: \\(S_t/S_0\\) lognormal distribution density \\(f\\), density \\(S_t\\) simply\n\\[g(s) = S_0^{-1}f(s/S_0),\\]\nscaled log-normal. helpful, e.g., comparing exact distribution \\(S_t\\) MC samples values \\(S_t\\), .","code":""},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"monte-carlo-simulation-of-the-gbm-model","chapter":"3 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"3.3 Monte Carlo simulation of the gBm model","text":"showed , exact solution geometric Brownian motion SDE—namely, continuous time random process characterized independent, normal log-returns disjoint time periods. Equivalently, given asset value \\(S_0\\) time zero know \\(S_t/S_0\\) log-normally distributed parameters given .Later, modify (complicate) gBm model take account several real-life phenomena including, e.g., time-varying volatility. augmented models necessarily explicit solutions like gBm model. Alternatively, can simulate many times model compute approximate solutions—called Monte Carlo. ’s needed gBm model, illustrate order take advantage simplified setting gBm moving complicated models.compare three methods computing \\(S_T\\) time \\(T\\), given \\(S_0\\), \\(\\sigma\\), \\(r\\): explicit solution due Ito, Monte Carlo (MC) simulation lognormal distribution, MC simulation paths asset values \\(S_s\\) discretization \\(s\\\\{s_0 = 0, s_1, \\ldots, s_{M+1} = T\\}\\). three provide answer (distributional sense) MC procedures contain additional MC variability (noise) decreases number simulations increases.","code":"import numpy as np\nimport numpy.random as npr\nimport matplotlib as mpl\nfrom matplotlib.pylab import plt \nimport math\nfrom scipy.stats import lognorm\nplt.style.use('seaborn')\nmpl.rcParams['font.family'] = 'serif'\n\n\nS0 = 100\nr = 0.05\nsigma = 0.25\nT = 2.0\n\n# Exact density of ST based on gBm model\nmu = np.exp((r - sigma**2/2)*T)\ns = sigma * math.sqrt(T)\nx = np.linspace(lognorm.ppf(0.001, s, scale = mu), lognorm.ppf(0.999, s, scale = mu), 1000)\n\n\n# MC sampling of density of ST\nI=10000\nST = S0 * np.exp((r-0.5*sigma**2)*T + sigma*math.sqrt(T)*npr.standard_normal(I))\n\n\n# MC sampling of asset price path S0 to ST at 50 equally-spaced timepoints\nM=50\ndt = T / M\nS = np.zeros((M+1, I))\nS[0] = S0\nfor t in range(1,M+1):\n    S[t]=S[t-1]*np.exp((r - 0.5*sigma**2)*dt + sigma*math.sqrt(dt)*npr.standard_normal(I))\n\n\n# Plots of asset Price distribution at T = 2\nplt.figure(figsize = (10,6))\nplt.subplot(211)\n# histogram of MC samples from scaled log-normal\nhist1 = plt.hist(ST,100,density = True)\n# scaled log-normal density\ndens = plt.plot(x*S0, (1/S0)*lognorm.pdf(x, s, scale = mu),\n       'r-', lw=2, alpha=0.6)\nplt.ylabel('Asset Price')\nplt.title('Exact and MC-simulated Asset Price at Time T=2')\nplt.xlim([0,400])\n#plt.ylim([0,0.0014])## (0.0, 400.0)plt.subplot(212)\n# histogram of path-wise MC samples from scaled log-normal over grid of 50 times\nhist2 = plt.hist(S[-1],100,density = True)\ndens = plt.plot(x*S0, (1/S0)*lognorm.pdf(x, s, scale = mu),\n       'r-', lw=2, alpha=0.6)\nplt.ylabel('Asset Price')\nplt.xlabel('Time')\nplt.xlim([0,400])\n#plt.ylim([0,0.0014])## (0.0, 400.0)plt.show()"},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"off-on-a-tangent-reducing-mc-variability","chapter":"3 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"3.4 Off on a tangent: reducing MC variability","text":"difference theoretic (exact) values mean standard deviation \\(S_T\\) corresponding MC approximations (shown ) due MC error. Law Large Numbers (LLN) implies MC error declines zero number MC samples increases infinity. practice, using many MC samples order reduce MC error trade-increasing computation time (memory usage storing random variates vector). hand, ways reduce MC error making clever choices MC samples.simplest way reduce MC variability (besides increasing number samples) use anti-thetical variates. sampling standard normal random variates amounts sampling \\(z\\) using \\((z,-z)\\) samples. get \\(2I\\) samples one needs actually compute \\(\\) samples, remaining \\(\\) magnitude opposite signs. accomplishes exact mean-matching, .e., \\((2I)^{-1}\\sum_{=1}^{2I} z_i = 0\\), exactly standard normal distribution mean. Another method reducing MC variability second-moment matching. Suppose generate antithetical samples \\(z = (z_1, \\ldots, z_I)\\). Let \\(z^\\star_i := z_i / s_{z}\\) \\(=1, \\ldots, \\) \\(s_z\\) sample standard deviation \\(z\\). Now, \\(z^\\star\\) sample mean exactly zero sample standard deviation exactly \\(1\\). , Box-Cox transformation may used samples \\(z\\) positive skew. (negative skew, samples may reflected maximum value produce set positively-skewed values starting zero.) applying Box-cox transformation, resulting values \\(y\\) close symmetric (closer normal distribution original variates) standardization \\(z^\\star_i = (y_i - \\overline y)/s_y\\) may used transform values approximately standard normal.following simulation supports use standardized antithetic variates. design, exactly zero mean unit variance, slightly likely skewed compared vanilly MC samples. Box-Cox transformed variates perform better, likely display excess kurtosis even vanilla MC variates. worth pointing antithetic variates may produced sequentially standardized variates requires storing variates memory, may problem applications.","code":"import scipy.stats  as scs\n\ndef print_stats(a2,a3):\n    stat2 = scs.describe(a2)\n    stat3 = scs.describe(a3)\n    print('%14s %14s %14s %14s' % ('statistic', 'data set 1', 'data set 2', 'data set 3'))\n    print(45 * '-')\n    print('%14s %14s %14.3f %14.3f' % ('size', 'NA', stat2[0], stat3[0]))\n    print('%14s %14s %14.3f %14.3f' % ('min', 'NA', stat2[1][0], stat3[1][0] ))\n    print('%14s %14s %14.3f %14.3f' % ('max', 'NA', stat2[1][1], stat3[1][1]))\n    print('%14s %14.3f %14.3f %14.3f' % ('mean', S0*math.exp(r*T), stat2[2], stat3[2]))\n    print('%14s %14.3f %14.3f %14.3f' % ('stdev', S0*math.sqrt((math.exp(sigma**2 * T)-1)*math.exp(2*r*T)), np.sqrt(stat2[3]), np.sqrt(stat3[3])))\n\n\nprint_stats(ST, S[-1])##      statistic     data set 1     data set 2     data set 3\n## ---------------------------------------------\n##           size             NA      10000.000      10000.000\n##            min             NA         27.889         24.378\n##            max             NA        420.599        433.723\n##           mean        110.517        110.258        110.429\n##          stdev         40.327         40.989         39.900import scipy.stats  as scs\nimport numpy  as np\nimport numpy.random  as npr\n\ndef bc_standardize(z):\n  M = np.max(z)\n  zM = M-z+0.0000001\n  y = scs.boxcox(zM)\n  m = np.mean(y[0])\n  s = np.std(y[0], ddof=1)\n  z_star = (y[0]-m)/s\n  return z_star\n\ndef at_standardize(z):\n  s = np.std(z, ddof=1)\n  z_star = z/s\n  return z_star\n\nkurtosis_vals = np.zeros((1000,8))\nskew_vals = np.zeros_like(kurtosis_vals)\nmean_vals = np.zeros_like(kurtosis_vals)\nstd_vals = np.zeros_like(kurtosis_vals)\n\ndef print_stats2():\n  for i in range(1,1001):\n    X = npr.standard_normal(10000)\n    Z1 = npr.standard_normal(5000)\n    Z2 = npr.standard_normal(5000)\n    Z3 = -Z1\n    Z4 = -Z2\n    Z = np.concatenate((Z1,Z2))\n    Y = np.concatenate((Z1,Z3))\n    W = np.concatenate((Z2,Z4))\n    Ystar = bc_standardize(Y)\n    Wstar = bc_standardize(W)\n    Yst = at_standardize(Y)\n    Wst = at_standardize(W)\n    stat1 = scs.describe(X, ddof = 1)\n    stat2 = scs.describe(Z, ddof = 1)\n    stat3 = scs.describe(Y, ddof = 1)\n    stat4 = scs.describe(W, ddof = 1)\n    stat5 = scs.describe(Ystar, ddof = 1)\n    stat6 = scs.describe(Wstar, ddof = 1)\n    stat7 = scs.describe(Yst, ddof = 1)\n    stat8 = scs.describe(Wst, ddof = 1)\n    mean_vals[i-1,:] = np.array([stat1[2], stat2[2], stat3[2], stat4[2], stat5[2], stat6[2], stat7[2], stat8[2]])\n    std_vals[i-1,:] = np.array([stat1[3], stat2[3], stat3[3], stat4[3], stat5[3], stat6[3], stat7[3], stat8[3]])\n    kurtosis_vals[i-1,:] = np.array([stat1[4], stat2[4], stat3[4], stat4[4], stat5[4], stat6[4], stat7[4], stat8[4]])\n    skew_vals[i-1,:] = np.array([stat1[5], stat2[5], stat3[5], stat4[5], stat5[5], stat6[5], stat7[5], stat8[5]])\n\n  print('%14s %14s %14s %14s %14s %14s %14s %14s %14s' % ('statistic', 'data set 1', 'data set 2', 'data set 3', 'data set 4', 'data set 5', 'data set 6', 'data set 7', 'data set 8'))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('mean mean', np.mean(mean_vals[:,0]), np.mean(mean_vals[:,1]), np.mean(mean_vals[:,2]), np.mean(mean_vals[:,3]), np.mean(mean_vals[:,4]), np.mean(mean_vals[:,5]), np.mean(mean_vals[:,6]), np.mean(mean_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('std mean', np.std(mean_vals[:,0]), np.std(mean_vals[:,1]), np.std(mean_vals[:,2]), np.std(mean_vals[:,3]), np.std(mean_vals[:,4]), np.std(mean_vals[:,5]), np.std(mean_vals[:,6]), np.std(mean_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('mean std', np.mean(std_vals[:,0]), np.mean(std_vals[:,1]), np.mean(std_vals[:,2]), np.mean(std_vals[:,3]), np.mean(std_vals[:,4]), np.mean(std_vals[:,5]), np.mean(std_vals[:,6]), np.mean(std_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('std std', np.std(std_vals[:,0]), np.std(std_vals[:,1]), np.std(std_vals[:,2]), np.std(std_vals[:,3]), np.std(std_vals[:,4]), np.std(std_vals[:,5]), np.std(std_vals[:,6]), np.std(std_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('mean kurtosis', np.mean(kurtosis_vals[:,0]), np.mean(kurtosis_vals[:,1]), np.mean(kurtosis_vals[:,2]), np.mean(kurtosis_vals[:,3]), np.mean(kurtosis_vals[:,4]), np.mean(kurtosis_vals[:,5]), np.mean(kurtosis_vals[:,6]), np.mean(kurtosis_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('std kurtosis', np.std(kurtosis_vals[:,0]), np.std(kurtosis_vals[:,1]), np.std(kurtosis_vals[:,2]), np.std(kurtosis_vals[:,3]), np.std(kurtosis_vals[:,4]), np.std(kurtosis_vals[:,5]), np.std(kurtosis_vals[:,6]), np.std(kurtosis_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('mean skew', np.mean(skew_vals[:,0]), np.mean(skew_vals[:,1]), np.mean(skew_vals[:,2]), np.mean(skew_vals[:,3]), np.mean(skew_vals[:,4]), np.mean(skew_vals[:,5]), np.mean(skew_vals[:,6]), np.mean(skew_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('std skew', np.std(skew_vals[:,0]), np.std(skew_vals[:,1]), np.std(skew_vals[:,2]), np.std(skew_vals[:,3]), np.std(skew_vals[:,4]), np.std(skew_vals[:,5]), np.std(skew_vals[:,6]), np.std(skew_vals[:,7])))\n  \nprint_stats2()  ##      statistic     data set 1     data set 2     data set 3     data set 4     data set 5     data set 6     data set 7     data set 8\n##      mean mean         -0.000          0.000         -0.000         -0.000          0.000         -0.000         -0.000         -0.000\n##       std mean          0.010          0.010          0.000          0.000          0.000          0.000          0.000          0.000\n##       mean std          1.000          1.000          0.999          1.001          1.000          1.000          1.000          1.000\n##        std std          0.014          0.015          0.020          0.020          0.000          0.000          0.000          0.000\n##  mean kurtosis         -0.001          0.000          0.000         -0.000         -0.010         -0.010          0.000         -0.000\n##   std kurtosis          0.024          0.024          0.000          0.000          0.007          0.007          0.000          0.000\n##      mean skew          0.000          0.000         -0.001         -0.000          0.004          0.004         -0.001         -0.000\n##       std skew          0.050          0.050          0.069          0.071          0.066          0.068          0.069          0.071"}]
