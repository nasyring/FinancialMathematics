[{"path":"index.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"","code":""},{"path":"intro.html","id":"intro","chapter":"2 Introduction","heading":"2 Introduction","text":"","code":""},{"path":"the-risk-neutral-framework.html","id":"the-risk-neutral-framework","chapter":"3 The risk-neutral framework","heading":"3 The risk-neutral framework","text":"key concept understanding section existence risk-free interest rate \\(r\\) one may invest cash accumulate future chance loss/default. practice, US treasury rates LIBOR may used near-riskless rates.","code":""},{"path":"the-risk-neutral-framework.html","id":"forwards","chapter":"3 The risk-neutral framework","heading":"3.1 Forwards","text":"forward promise now buy asset (think stock) prescribed future time \\(T\\). price forward, paid time \\(T\\)?Someone experience probability statistics might come following answer. Suppose perfect model future price, say, \\(\\log S_T/S_0 = X\\) \\(X\\sim N(\\mu, \\sigma^2)\\); , log price change normal fluctuation . price forward, say \\(F\\), paid time \\(T\\), payoff forward \\(S_T - F\\). value payoff time \\(0\\) \\(e^{-rT}(S_T - F)\\) expected value payoff time \\(0\\) \n\\[E(e^{-rT}(S_T - F)) = e^{-rT}\\left[S_0e^{\\mu + \\sigma^2/2}-F\\right].\\]\nseem either holder seller forward contract disadvantaged \\(F\\) anything \\(S_0e^{\\mu + \\sigma^2/2}\\), incorrect!’s . Pretend seller/writer forward contract. Borrow \\(S_0\\) time \\(t=0\\) buy one share. time \\(T\\) deliver stock \\(K\\) repay loan \\(S_0e^{rT}\\). \\(K > S_0e^{rT}\\) made riskless profit, .e., arbitrage. hand, suppose buyer/holder forward contract. Short share time \\(0\\) recieve \\(S_0\\), investing risk free rate \\(r\\). time \\(T\\) \\(S_0e^{rT}\\), buy stock \\(F\\), close short position. \\(F < S_0e^{rT}\\) make riskless profit.pricing lesson forward price \\(F\\) must simply current asset price accumulated risk-free rate; price results arbitrage. bigger picture lesson probabilities asset value changes irrelevant—initial asset value risk free rate (information known time 0) played role arbitrage-free pricing forward contract. phenomenon arbitrage-free prices agnostic towards probabilities future asset value moves known risk-neutrality.Forwards simple financial instruments, turns argument risk-neutral pricing applies arbitrary derivatives, see next.","code":""},{"path":"the-risk-neutral-framework.html","id":"risk-neutral-pricing-of-derivatives","chapter":"3 The risk-neutral framework","heading":"3.2 Risk-neutral pricing of derivatives","text":"Consider derivative provides payoff based value underlying asset, example, stock. modeling stock’s future price moves can replicate derivative using portfolio consisting \\((\\phi, \\psi)\\) units stock risk-free bond.model consists probabilities prescribed moves discrete time points. example, stock value \\(S_0\\) time \\(0\\) either moves value \\(S_2\\) time 1 probability \\(p\\) value \\(S_1\\) time \\(1\\) probability \\(1-p\\). portfolio value either \\(\\phi S_2 + \\psi B_0e^{r}\\) \\(\\phi S_1 + \\psi B_0e^{r}\\) time \\(1\\). , derivative value either \\(f(S_2)\\) \\(f(S_1)\\) time \\(1\\). Set potential portfolio values equal potential derivative values solve \\(\\phi, \\psi\\), yielding\n\\[\\phi = \\frac{f(S_2)-f(S_1)}{S_2 - S_1}\\quad\\text{}\\quad \\psi = B_0^{-1}e^{-r}[f(S_2) - \\phi S_2].\\]portfolio value time 0 \n\\[\\phi S_0 + \\psi B_0 = S_0 \\frac{f(S_2)-f(S_1)}{S_2 - S_1} + e^{-r}\\left\\{f(S_2) - \\frac{f(S_2)-f(S_1)}{S_2 - S_1}S_2\\right\\}.\\]\nenforceable price derivative deviation (excess bid-ask spreads) creates arbitrage opportunity using replicating portfolio derivative.Let \\(q := (S_0 e^r - S_1)/(S_2-S_1)\\) note portfolio value may rewritten \n\\[e^{-r}\\left\\{qf(S_2) + (1-q)f(S_1)\\right\\}.\\]\nappears discounted expected value. , indeed, \\(q<0\\) future stock price definitely higher bond’s future value, \\(q>1\\) bond certainly valuable stock. Therefore \\(q\\(0,1)\\) behaves like probability. call probabilities \\((q,1-q)\\) risk-neutral probabilities risk-neutral measure depend underlying true probabilities \\((p,1-p)\\) stock moves; rather result ofthe arbitrage-free market constraint.","code":""},{"path":"the-risk-neutral-framework.html","id":"binomial-derivative-pricing-model","chapter":"3 The risk-neutral framework","heading":"3.3 Binomial derivative pricing model","text":"previous argument derivative pricing using replicating portfolio based asset moves suggests practical pricing model. real life asset may move anywhere large, continuous range time point time point, may experience substantial volatility, model allowing one one move realistic. , simply increase number time points within time interval allow jump time point, can build risch model asset price time.Let \\(\\Delta_t\\) denote size time step. time point \\(\\) stock takes one \\(2^\\) values, , time \\(+1\\), \\(2^{+1}\\) values. Suppose time \\(\\), value \\(S_j^\\) \\(2^{}\\). ,\n\\[f(S_j^) = e^{-r\\Delta_t}\\left\\{q_j^(S_{j,u}^)+(1-q_j^)f(S_{j,d}^)\\right\\}\\]\n\\((S_{j,u}^, S_{j,d}^)\\) stock moves \\(S_j^\\), \n\\[q_j^= \\frac{S_j^e^{r\\Delta_t} - S_{j,d}^}{S_{j,u}^-S_{j,d}^}.\\]Notice derivative prices can now computed recursively top tree (end time interval) bottom (start time interval). example, consider following four-period tree stock prices (jump probabilities omitted):\nSuppose derivative pricing European call strike \\(95\\). time 3, top bottom, payoffs 35, 15, 0, 0, 10, 0, 0, 0. Suppose \\(r = 3\\%\\) timestep \\(\\Delta_t = 1\\) simplicity. , time 2 node \\(120\\), \\(q = (120 e^{0.03} - 110)/20 = 0.6827\\) \\(1-q=0.3173\\). price derivative node 120 \\(e^{-0.03}(0.6827\\times 35 + 0.3173 \\times 15) = 27.8077\\). price 80 node 0.Similarly, price derivative \\(95\\) node \\(10e^{-0.03}\\cdot q\\) \\(q = (95 e^{0.03} - 90)/15 = 0.5262\\), yielding price \\(5.1066\\).Backtracking time 1 nodes, derivative prices 22.50 node 110 4.3959 node 90. Finally, time 0 (node 100) find price 15.72579.","code":""},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation","chapter":"4 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"4 The geometric Brownian motion model of asset value and Monte Carlo simulation","text":"","code":""},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"asset-values-as-random-variables","chapter":"4 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"4.1 Asset values as random variables","text":"Let \\(\\{S_t, t\\geq 0\\}\\) denote values asset times \\(t\\). Ideally, think time continuum, \\(S_t\\) continuous process. Practically, however, approximate continuous process discrete one performing computations associated process grid \\(t\\) values interval \\([0,T]\\) mesh-size \\(\\Delta t\\).model process \\(S_t\\) random stochastic sequence; essentially, just sequence realizations random variables.plot Apple’s (AAPL) close--day stock price logarithm return \\(\\log(S_t/S_{t-1})\\) initial listing present day. Stock prices available much often daily, data visualized already represent discretization underlying process (mesh-size 1 day).","code":"import numpy as np\nimport numpy.random as npr\nimport matplotlib as mpl\nfrom matplotlib.pylab import plt \nimport math\n\nplt.style.use('seaborn')\nmpl.rcParams['font.family'] = 'serif'\n\nimport pandas as pd\nimport yfinance as yf\nfrom yahoofinancials import YahooFinancials\n\naapl_df = yf.download('AAPL')## \n[*********************100%***********************]  1 of 1 completedclose_price = aapl_df['Adj Close']\nlog_rets = np.log(close_price / close_price.shift(1))\naapl_df['log_rets'] = log_rets\naapl_df[['Adj Close', 'log_rets']].plot(subplots=True, figsize=(10, 6))## array([<AxesSubplot:xlabel='Date'>, <AxesSubplot:xlabel='Date'>],\n##       dtype=object)plt.show();"},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"geometric-brownian-motion-model-of-asset-prices-over-time","chapter":"4 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"4.2 Geometric Brownian motion model of asset prices over time","text":"mathematics continuous stochastic processes advanced. Rather presenting full account focus intermediate level understanding one common models used asset prices. Later modify model account several real-life phenomena.folk-wisdom log returns asset \\(\\log\\frac{S_t}{S_{t-1}}\\) normally-distributed, , rather, modeled . comes consequence modeling sequence asset prices geometric Brownian motion.Brownian motion (also called Wiener process) essentially sequence normal random variables. Specifically, process \\(W_t\\) satisfies\n- \\(W_0 = 0\\)\n- \\(W_t\\) continuous .s.\n- \\(W_t\\) independent increments\n- \\(W_t - W_s \\sim N(0,t-s)\\) \\(0\\leq s\\leq t\\)\nAdditionally, sequence measurable respect filtration, ordered family sigma-fields (details see, example, Resnick’s Probability Path Chapter 10).geometric Brownian motion (gBm) model says changes asset price time \\(t\\) time \\(t+s\\) determined Brownian motion drift. typically written following fashion stochastic differential equation (SDE) respect instantaneous price change:\n\\[dS_t = rS_tdt + \\sigma S_t dW_t\\]\n\\(r\\) risk-free interest rate, \\(dt\\) instantaneous change time, \\(\\sigma\\) volatility (standard deviation) parameter, \\(W_t\\) Brownian motion.important keep mind SDE doesn’t really mean anything—rather, simply notation used express stochastic integral concise manner. meaningful expression geometric Brownian motion model given difference equation\n\\[S_{t+s} = S_t = \\int_t^{t+s} rS_u\\,du + \\int_{t}^{t+s} \\sigma S_u \\, dW_u.\\]\nprimary challenge overcome define integration respect Brownian motion \\(W_u\\). various technical reasons, integration behave exactly way integration works real-valued functions, .e., Riemann integration. new theory integration, Ito integration, needed.Rather giving thorough treatment Ito’s calculus, simply provide informal derivation Ito’s Lemma, enough provide ``solution” geometric Brownian motion. Let \\(f(t,\\,S_t)\\) function time asset price time \\(t\\). Take two term Taylor expansion \\(f\\) use geometric Brownian motion SDE chain rule follows:\\[\\begin{align*}\ndf &= \\frac{\\partial f}{\\partial t}dt + \\frac{\\partial f}{\\partial S_t}dS_t + \\frac{1}{2}\\frac{\\partial^2 f}{\\partial S_t^2}dS_t^2 + \\cdots\\\\\n& = \\frac{\\partial f}{\\partial t}dt + \\frac{\\partial f}{\\partial S_t}(rS_tdt + \\sigma S_t dW_t) + \\frac{1}{2}\\frac{\\partial^2 f}{\\partial S_t^2}(r^2S_t^2dt^2 + 2r\\sigma S_t^2 dtdW_t + \\sigma^2S_t^2dW_t^2) + \\cdots.\n\\end{align*}\\], Ito’s Lemma says \\(dW_t^2 = O(dt)\\) substitution \\(dW_t^2 = dt\\) justified, terms \\(dt^2\\) \\(dt\\,dW_t\\) ignorable may substituted zero. Taylor expansion simplifies, according Ito, \n\\[df = \\left(\\frac{\\partial f}{\\partial t} + r S_t\\frac{\\partial f}{\\partial S_t} +\\frac{\\sigma^2}{2}S_t^2\\frac{\\partial^2 f}{\\partial S_t^2}\\right)dt + \\sigma\\frac{\\partial f}{\\partial S_t}S_t \\,dW_t.\\]Now, let \\(f(t,\\, S_t):= \\log(S_t)\\), log asset price time \\(t\\). case, following derivatives:\n\\[\\partial f/\\partial t = 0\\quad \\partial f/\\partial S_t = 1/S_t \\quad \\partial^2 f/\\partial S_t^2 = -1/S_t^2.\\]\nSubstituting SDE , get\n\\[d\\log S_t = r\\,dt - \\frac{\\sigma^2}{2S_t^2}S_t^2\\,dt + \\frac{\\sigma}{S_t}S_t\\,dW_t. \\]\nNext integrate sides:\n\\[\\log S_t = \\log(S_0) + \\left(r - \\frac{\\sigma^2}{2}\\right)t + \\sigma\\, W_t.\\]\nExponentiate obtain\\[S_t = S_0\\exp\\left(rt - \\frac{\\sigma^2}{2}t+\\sigma \\, W_t\\right).\\]\nRecall \\(W_t - W_0 := W_t\\) variance \\(t\\) see \\(S_t/S_0\\) log-normally distributed parameters \\((r - \\sigma^2/2)t\\) \\(\\sigma\\, t^{1/2}\\), means right-skewed mean \\(\\exp(rt)\\) variance \\((\\exp(\\sigma^2 t)-1)\\cdot\\exp(2rt)\\).Armed Ito’s Lemma, confirmed folk-wisdom log-returns time \\(t\\) \\(t+s\\) (modeled ) normal random variables mean \\((r - \\frac{\\sigma^2}{2}) s\\) variance \\(\\sigma^2 s\\). One last minor point: \\(S_t/S_0\\) lognormal distribution density \\(f\\), density \\(S_t\\) simply\n\\[g(s) = S_0^{-1}f(s/S_0),\\]\nscaled log-normal. helpful, e.g., comparing exact distribution \\(S_t\\) MC samples values \\(S_t\\), .","code":""},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"monte-carlo-simulation-of-the-gbm-model","chapter":"4 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"4.3 Monte Carlo simulation of the gBm model","text":"showed , exact solution geometric Brownian motion SDE—namely, continuous time random process characterized independent, normal log-returns disjoint time periods. Equivalently, given asset value \\(S_0\\) time zero know \\(S_t/S_0\\) log-normally distributed parameters given .Later, modify (complicate) gBm model take account several real-life phenomena including, e.g., time-varying volatility. augmented models necessarily explicit solutions like gBm model. Alternatively, can simulate many times model compute approximate solutions—called Monte Carlo. ’s needed gBm model, illustrate order take advantage simplified setting gBm moving complicated models.compare three methods computing \\(S_T\\) time \\(T\\), given \\(S_0\\), \\(\\sigma\\), \\(r\\): explicit solution due Ito, Monte Carlo (MC) simulation lognormal distribution, MC simulation paths asset values \\(S_s\\) discretization \\(s\\\\{s_0 = 0, s_1, \\ldots, s_{M+1} = T\\}\\). three provide answer (distributional sense) MC procedures contain additional MC variability (noise) decreases number simulations increases.","code":"import numpy as np\nimport numpy.random as npr\nimport matplotlib as mpl\nfrom matplotlib.pylab import plt \nimport math\nfrom scipy.stats import lognorm\nplt.style.use('seaborn')\nmpl.rcParams['font.family'] = 'serif'\n\n\nS0 = 100\nr = 0.05\nsigma = 0.25\nT = 2.0\n\n# Exact density of ST based on gBm model\nmu = np.exp((r - sigma**2/2)*T)\ns = sigma * math.sqrt(T)\nx = np.linspace(lognorm.ppf(0.001, s, scale = mu), lognorm.ppf(0.999, s, scale = mu), 1000)\n\n\n# MC sampling of density of ST\nI=10000\nST = S0 * np.exp((r-0.5*sigma**2)*T + sigma*math.sqrt(T)*npr.standard_normal(I))\n\n\n# MC sampling of asset price path S0 to ST at 50 equally-spaced timepoints\nM=50\ndt = T / M\nS = np.zeros((M+1, I))\nS[0] = S0\nfor t in range(1,M+1):\n    S[t]=S[t-1]*np.exp((r - 0.5*sigma**2)*dt + sigma*math.sqrt(dt)*npr.standard_normal(I))\n\n\n# Plots of asset Price distribution at T = 2\nplt.figure(figsize = (10,6))\nplt.subplot(211)\n# histogram of MC samples from scaled log-normal\nhist1 = plt.hist(ST,100,density = True)\n# scaled log-normal density\ndens = plt.plot(x*S0, (1/S0)*lognorm.pdf(x, s, scale = mu),\n       'r-', lw=2, alpha=0.6)\nplt.ylabel('Asset Price')\nplt.title('Exact and MC-simulated Asset Price at Time T=2')\nplt.xlim([0,400])\n#plt.ylim([0,0.0014])## (0.0, 400.0)plt.subplot(212)\n# histogram of path-wise MC samples from scaled log-normal over grid of 50 times\nhist2 = plt.hist(S[-1],100,density = True)\ndens = plt.plot(x*S0, (1/S0)*lognorm.pdf(x, s, scale = mu),\n       'r-', lw=2, alpha=0.6)\nplt.ylabel('Asset Price')\nplt.xlabel('Time')\nplt.xlim([0,400])\n#plt.ylim([0,0.0014])## (0.0, 400.0)plt.show()"},{"path":"the-geometric-brownian-motion-model-of-asset-value-and-monte-carlo-simulation.html","id":"off-on-a-tangent-reducing-mc-variability","chapter":"4 The geometric Brownian motion model of asset value and Monte Carlo simulation","heading":"4.4 Off on a tangent: reducing MC variability","text":"difference theoretic (exact) values mean standard deviation \\(S_T\\) corresponding MC approximations (shown ) due MC error. Law Large Numbers (LLN) implies MC error declines zero number MC samples increases infinity. practice, using many MC samples order reduce MC error trade-increasing computation time (memory usage storing random variates vector). hand, ways reduce MC error making clever choices MC samples.simplest way reduce MC variability (besides increasing number samples) use anti-thetical variates. sampling standard normal random variates amounts sampling \\(z\\) using \\((z,-z)\\) samples. get \\(2I\\) samples one needs actually compute \\(\\) samples, remaining \\(\\) magnitude opposite signs. accomplishes exact mean-matching, .e., \\((2I)^{-1}\\sum_{=1}^{2I} z_i = 0\\), exactly standard normal distribution mean. Another method reducing MC variability second-moment matching. Suppose generate antithetical samples \\(z = (z_1, \\ldots, z_I)\\). Let \\(z^\\star_i := z_i / s_{z}\\) \\(=1, \\ldots, \\) \\(s_z\\) sample standard deviation \\(z\\). Now, \\(z^\\star\\) sample mean exactly zero sample standard deviation exactly \\(1\\). , Box-Cox transformation may used samples \\(z\\) positive skew. (negative skew, samples may reflected maximum value produce set positively-skewed values starting zero.) applying Box-cox transformation, resulting values \\(y\\) close symmetric (closer normal distribution original variates) standardization \\(z^\\star_i = (y_i - \\overline y)/s_y\\) may used transform values approximately standard normal.following simulation supports use standardized antithetic variates. design, exactly zero mean unit variance, slightly likely skewed compared vanilly MC samples. Box-Cox transformed variates perform better, likely display excess kurtosis even vanilla MC variates. worth pointing antithetic variates may produced sequentially standardized variates requires storing variates memory, may problem applications.","code":"import scipy.stats  as scs\n\ndef print_stats(a2,a3):\n    stat2 = scs.describe(a2)\n    stat3 = scs.describe(a3)\n    print('%14s %14s %14s %14s' % ('statistic', 'data set 1', 'data set 2', 'data set 3'))\n    print(45 * '-')\n    print('%14s %14s %14.3f %14.3f' % ('size', 'NA', stat2[0], stat3[0]))\n    print('%14s %14s %14.3f %14.3f' % ('min', 'NA', stat2[1][0], stat3[1][0] ))\n    print('%14s %14s %14.3f %14.3f' % ('max', 'NA', stat2[1][1], stat3[1][1]))\n    print('%14s %14.3f %14.3f %14.3f' % ('mean', S0*math.exp(r*T), stat2[2], stat3[2]))\n    print('%14s %14.3f %14.3f %14.3f' % ('stdev', S0*math.sqrt((math.exp(sigma**2 * T)-1)*math.exp(2*r*T)), np.sqrt(stat2[3]), np.sqrt(stat3[3])))\n\n\nprint_stats(ST, S[-1])##      statistic     data set 1     data set 2     data set 3\n## ---------------------------------------------\n##           size             NA      10000.000      10000.000\n##            min             NA         28.097         27.338\n##            max             NA        390.870        448.195\n##           mean        110.517        110.759        110.511\n##          stdev         40.327         40.583         40.726import scipy.stats  as scs\nimport numpy  as np\nimport numpy.random  as npr\n\ndef bc_standardize(z):\n  M = np.max(z)\n  zM = M-z+0.0000001\n  y = scs.boxcox(zM)\n  m = np.mean(y[0])\n  s = np.std(y[0], ddof=1)\n  z_star = (y[0]-m)/s\n  return z_star\n\ndef at_standardize(z):\n  s = np.std(z, ddof=1)\n  z_star = z/s\n  return z_star\n\nkurtosis_vals = np.zeros((1000,8))\nskew_vals = np.zeros_like(kurtosis_vals)\nmean_vals = np.zeros_like(kurtosis_vals)\nstd_vals = np.zeros_like(kurtosis_vals)\n\ndef print_stats2():\n  for i in range(1,1001):\n    X = npr.standard_normal(10000)\n    Z1 = npr.standard_normal(5000)\n    Z2 = npr.standard_normal(5000)\n    Z3 = -Z1\n    Z4 = -Z2\n    Z = np.concatenate((Z1,Z2))\n    Y = np.concatenate((Z1,Z3))\n    W = np.concatenate((Z2,Z4))\n    Ystar = bc_standardize(Y)\n    Wstar = bc_standardize(W)\n    Yst = at_standardize(Y)\n    Wst = at_standardize(W)\n    stat1 = scs.describe(X, ddof = 1)\n    stat2 = scs.describe(Z, ddof = 1)\n    stat3 = scs.describe(Y, ddof = 1)\n    stat4 = scs.describe(W, ddof = 1)\n    stat5 = scs.describe(Ystar, ddof = 1)\n    stat6 = scs.describe(Wstar, ddof = 1)\n    stat7 = scs.describe(Yst, ddof = 1)\n    stat8 = scs.describe(Wst, ddof = 1)\n    mean_vals[i-1,:] = np.array([stat1[2], stat2[2], stat3[2], stat4[2], stat5[2], stat6[2], stat7[2], stat8[2]])\n    std_vals[i-1,:] = np.array([stat1[3], stat2[3], stat3[3], stat4[3], stat5[3], stat6[3], stat7[3], stat8[3]])\n    kurtosis_vals[i-1,:] = np.array([stat1[4], stat2[4], stat3[4], stat4[4], stat5[4], stat6[4], stat7[4], stat8[4]])\n    skew_vals[i-1,:] = np.array([stat1[5], stat2[5], stat3[5], stat4[5], stat5[5], stat6[5], stat7[5], stat8[5]])\n\n  print('%14s %14s %14s %14s %14s %14s %14s %14s %14s' % ('statistic', 'data set 1', 'data set 2', 'data set 3', 'data set 4', 'data set 5', 'data set 6', 'data set 7', 'data set 8'))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('mean mean', np.mean(mean_vals[:,0]), np.mean(mean_vals[:,1]), np.mean(mean_vals[:,2]), np.mean(mean_vals[:,3]), np.mean(mean_vals[:,4]), np.mean(mean_vals[:,5]), np.mean(mean_vals[:,6]), np.mean(mean_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('std mean', np.std(mean_vals[:,0]), np.std(mean_vals[:,1]), np.std(mean_vals[:,2]), np.std(mean_vals[:,3]), np.std(mean_vals[:,4]), np.std(mean_vals[:,5]), np.std(mean_vals[:,6]), np.std(mean_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('mean std', np.mean(std_vals[:,0]), np.mean(std_vals[:,1]), np.mean(std_vals[:,2]), np.mean(std_vals[:,3]), np.mean(std_vals[:,4]), np.mean(std_vals[:,5]), np.mean(std_vals[:,6]), np.mean(std_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('std std', np.std(std_vals[:,0]), np.std(std_vals[:,1]), np.std(std_vals[:,2]), np.std(std_vals[:,3]), np.std(std_vals[:,4]), np.std(std_vals[:,5]), np.std(std_vals[:,6]), np.std(std_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('mean kurtosis', np.mean(kurtosis_vals[:,0]), np.mean(kurtosis_vals[:,1]), np.mean(kurtosis_vals[:,2]), np.mean(kurtosis_vals[:,3]), np.mean(kurtosis_vals[:,4]), np.mean(kurtosis_vals[:,5]), np.mean(kurtosis_vals[:,6]), np.mean(kurtosis_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('std kurtosis', np.std(kurtosis_vals[:,0]), np.std(kurtosis_vals[:,1]), np.std(kurtosis_vals[:,2]), np.std(kurtosis_vals[:,3]), np.std(kurtosis_vals[:,4]), np.std(kurtosis_vals[:,5]), np.std(kurtosis_vals[:,6]), np.std(kurtosis_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('mean skew', np.mean(skew_vals[:,0]), np.mean(skew_vals[:,1]), np.mean(skew_vals[:,2]), np.mean(skew_vals[:,3]), np.mean(skew_vals[:,4]), np.mean(skew_vals[:,5]), np.mean(skew_vals[:,6]), np.mean(skew_vals[:,7])))\n  print('%14s %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f %14.3f' % ('std skew', np.std(skew_vals[:,0]), np.std(skew_vals[:,1]), np.std(skew_vals[:,2]), np.std(skew_vals[:,3]), np.std(skew_vals[:,4]), np.std(skew_vals[:,5]), np.std(skew_vals[:,6]), np.std(skew_vals[:,7])))\n  \nprint_stats2()  ##      statistic     data set 1     data set 2     data set 3     data set 4     data set 5     data set 6     data set 7     data set 8\n##      mean mean          0.000         -0.000         -0.000          0.000         -0.000          0.000         -0.000          0.000\n##       std mean          0.010          0.010          0.000          0.000          0.000          0.000          0.000          0.000\n##       mean std          0.998          1.000          1.001          1.000          1.000          1.000          1.000          1.000\n##        std std          0.014          0.014          0.020          0.020          0.000          0.000          0.000          0.000\n##  mean kurtosis         -0.000         -0.001         -0.000         -0.000         -0.010         -0.010         -0.000          0.000\n##   std kurtosis          0.025          0.023          0.000          0.000          0.006          0.007          0.000          0.000\n##      mean skew         -0.001         -0.001         -0.002         -0.002          0.002          0.003         -0.002         -0.002\n##       std skew          0.048          0.047          0.066          0.069          0.063          0.067          0.066          0.069"},{"path":"a-flexible-derivative-pricing-model.html","id":"a-flexible-derivative-pricing-model","chapter":"5 A flexible derivative pricing model","heading":"5 A flexible derivative pricing model","text":"model consider section Bakshi-Cao- (BCC) model “Empirical Performance Alternative Option Pricing Models” Journal Finance, Vol. 52, . 5 (Dec., 1997), pp. 2003-2049.BCC model characterized jump-diffusion model asset price, square-root diffusion process stochastic volatility, Cox-Ingersoll-Ross (CIR) stochastic short-term interest rate. Formally, model may expressed follows:\n\\[\\begin{align*}\ndS_t &= (r_t - r_J)S_tdt + \\sqrt{v_t}S_tdZ_t^1 + J_tS_tdN_t\\\\\ndv_t &= \\kappa_v(\\theta_v - v_t)dt + \\sigma_v\\sqrt{v_t}dZ_t^2\\\\\ndr_t &= \\kappa_r(\\theta_r - r_t)dt + \\sigma_r\\sqrt{r_t}dZ_t^3.\n\\end{align*}\\]","code":""},{"path":"a-flexible-derivative-pricing-model.html","id":"present-value-with-stochastic-short-term-rate","chapter":"5 A flexible derivative pricing model","heading":"5.1 Present-value with stochastic short-term rate","text":"continuous compounding present value time \\(t\\) dollar paid time \\(T\\) \n\\[B_0(T) = E_t^Q\\left(\\exp\\left\\{-\\int_t^T r_udu\\right\\}\\right).\\]\nadvantage CIR model discounting closed-form:\n\\[\\begin{align*}\nB_t(T) &= b_1(T)e^{-b_2(T)r_0}\\\\\nb_1(T) &= \\left(\\frac{2\\gamma \\exp((\\kappa_r+\\gamma)T/2)}{2\\gamma + (\\kappa_r + \\gamma)(e^{\\gamma T}-1)}\\right)^{\\frac{2\\kappa_r\\theta_r}{\\sigma_r^2}}\\\\\nb_2(T) &= \\frac{2(e^{\\gamma T}-1)}{2\\gamma + (\\kappa_r + \\gamma)(e^{\\gamma T}-1)}\\\\\n\\gamma = \\sqrt{\\kappa_r^2 + 2\\sigma_r^2}\n\\end{align*}\\]following python codes implement discounting CIR model.","code":"import math\nimport numpy as np\n\nkappa_r, theta_r, sigma_r, r0, T = 0.3, 0.04, 0.1, 0.04, 1.0\n\ndef gamma(kappa_r, sigma_r):\n  ''' Help Function. '''\n  return math.sqrt(kappa_r ** 2 + 2 * sigma_r ** 2)\n\ndef b1(alpha):\n  ''' Help Function. '''\n  kappa_r, theta_r, sigma_r, r0, T = alpha\n  g = gamma(kappa_r, sigma_r)\n  return (((2 * g * math.exp((kappa_r + g) * T / 2)) /(2 * g + (kappa_r + g) * (math.exp(g * T) - 1)))** (2 * kappa_r * theta_r / sigma_r ** 2))\n\n\ndef b2(alpha):\n  ''' Help Function. '''\n  kappa_r, theta_r, sigma_r, r0, T = alpha\n  g = gamma(kappa_r, sigma_r)\n  return ((2 * (math.exp(g * T) - 1)) /(2 * g + (kappa_r + g) * (math.exp(g * T) - 1)))\n\ndef B(alpha):\n  ''' Function to value unit zero-coupon bonds in Cox-Ingersoll-Ross (1985)\n  model.\n  Parameters\n  ==========\n  r0: float\n  initial short rate\n  kappa_r: float\n  mean-reversion factor\n  theta_r: float\n  long-run mean of short rate\n  sigma_r: float\n  volatility of short rate\n  T: float\n  time horizon/interval\n  Returns\n  =======\n  zcb_value: float\n  zero-coupon bond present value\n  '''\n  b_1 = b1(alpha)\n  b_2 = b2(alpha)\n  kappa_r, theta_r, sigma_r, r0, T = alpha\n  return b_1 * math.exp(-b_2 * r0)\n\nif __name__ == '__main__':\n  #\n  # Example Valuation\n  #\n  B0T = B([kappa_r, theta_r, sigma_r, r0, T])\n  # discount factor, ZCB value\n  print(\"ZCB Value %10.4f\" % B0T)## ZCB Value     0.9608"},{"path":"a-flexible-derivative-pricing-model.html","id":"evaluating-a-european-option-via-fourier-transform","chapter":"5 A flexible derivative pricing model","heading":"5.2 Evaluating a European option via Fourier transform","text":"","code":"import numpy as np\nfrom scipy.integrate import quad\nimport warnings\nwarnings.simplefilter('ignore')\n\n#\n# Example Parameters B96 Model\n#\n## H93 Parameters\nkappa_v = 1.5\ntheta_v = 0.02\nsigma_v = 0.15\nrho = 0.1\nv0 = 0.01\n## M76 Parameters\nlamb = 0.25\nmu = -0.2\ndelta = 0.1\nsigma = np.sqrt(v0)\n## General Parameters\nS0 = 100.0\nK = 100.0\nT = 1.0\nr = 0.05\n\ndef BCC_call_value(S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta):\n  ''' Valuation of European call option in B96 Model via Lewis (2001)\n  Fourier-based approach.\n  Parameters\n  ==========\n  S0: float\n  initial stock/index level\n  K: float\n  strike price\n  T: float\n  time-to-maturity (for t=0)\n  r: float\n  constant risk-free short rate\n  kappa_v: float\n  mean-reversion factor\n  theta_v: float\n  long-run mean of variance\n  sigma_v: float\n  volatility of variance\n  rho: float\n  correlation between variance and stock/index level\n  v0: float\n  initial level of variance\n  lamb: float\n  jump intensity\n  mu: float\n  expected jump size\n  delta: float\n  standard deviation of jump\n  Returns\n  =======\n  call_value: float\n  present value of European call option\n  '''\n  int_value = quad(lambda u: BCC_int_func(u, S0, K, T, r, kappa_v, theta_v,sigma_v, rho, v0, lamb, mu, delta), 0, np.inf,limit=250)[0]\n  call_value = max(0, S0 - np.exp(-r * T) * np.sqrt(S0 * K)/ np.pi * int_value)\n  return call_value\n\ndef H93_call_value(S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0):\n  ''' Valuation of European call option in H93 model via Lewis (2001)\n  Fourier-based approach.\n  Parameters\n  ==========\n  S0: float\n  initial stock/index level\n  K: float\n  strike price\n  T: float\n  time-to-maturity (for t=0)\n  r: float\n  constant risk-free short rate\n  kappa_v: float\n  mean-reversion factor\n  theta_v: float\n  long-run mean of variance\n  sigma_v: float\n  volatility of variance\n  rho: float\n  correlation between variance and stock/index level\n  v0: float\n  initial level of variance\n  Returns\n  =======\n  call_value: float\n  present value of European call option\n  '''\n  int_value = quad(lambda u: H93_int_func(u, S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0), 0, np.inf, limit=250)[0]\n  call_value = max(0, S0 - np.exp(-r * T) * np.sqrt(S0 * K)/ np.pi * int_value)\n  return call_value\n\ndef M76_call_value(S0, K, T, r, v0, lamb, mu, delta):\n  ''' Valuation of European call option in M76 model via Lewis (2001)\n  Fourier-based approach.\n  Parameters\n  ==========\n  S0: float\n  initial stock/index level\n  K: float\n  strike price\n  T: float\n  time-to-maturity (for t=0)\n  r: float\n  constant risk-free short rate\n  lamb: float\n  jump intensity\n  mu: float\n  expected jump size\n  delta: float\n  standard deviation of jump\n  Returns\n  =======\n  call_value: float\n  present value of European call option\n  '''\n  sigma = np.sqrt(v0)\n  int_value = quad(lambda u: M76_int_func_sa(u, S0, K, T, r,\n  sigma, lamb, mu, delta), 0, np.inf, limit=250)[0]\n  call_value = max(0, S0 - np.exp(-r * T) * np.sqrt(S0 * K)/ np.pi * int_value)\n  return call_value\n\ndef BCC_int_func(u, S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0,lamb, mu, delta):\n  ''' Valuation of European call option in BCC97 model via Lewis (2001)\n  Fourier-based approach: integration function.\n  Parameter definitions see function BCC_call_value.'''\n  char_func_value = BCC_char_func(u - 1j * 0.5, T, r, kappa_v, theta_v, sigma_v, rho, v0, lamb, mu, delta)\n  int_func_value = 1 / (u ** 2 + 0.25) * (np.exp(1j * u * np.log(S0 / K)) * char_func_value).real\n  return int_func_value\n\ndef H93_int_func(u, S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0):\n  ''' Valuation of European call option in H93 model via Lewis (2001)\n  Fourier-based approach: integration function.\n  Parameter definitions see function H93_call_value.'''\n  char_func_value = H93_char_func(u - 1j * 0.5, T, r, kappa_v, theta_v, sigma_v, rho, v0)\n  int_func_value = 1 / (u ** 2 + 0.25) * (np.exp(1j * u * np.log(S0 / K)) * char_func_value).real\n  return int_func_value\n\n\ndef M76_int_func_sa(u, S0, K, T, r, sigma, lamb, mu, delta):\n  ''' Valuation of European call option in M76 model via Lewis (2001)\n  Fourier-based approach: integration function.\n  Parameter definitions see function M76_call_value.'''\n  char_func_value = M76_char_func_sa(u - 0.5 * 1j, T, r, sigma, lamb, mu, delta)\n  int_func_value = 1 / (u ** 2 + 0.25) * (np.exp(1j * u * np.log(S0 / K)) * char_func_value).real\n  return int_func_value\n\ndef BCC_char_func(u, T, r, kappa_v, theta_v, sigma_v, rho, v0,lamb, mu, delta):\n  ''' Valuation of European call option in BCC97 model via Lewis (2001)\n  Fourier-based approach: characteristic function.\n  Parameter definitions see function BCC_call_value.'''\n  BCC1 = H93_char_func(u, T, r, kappa_v, theta_v, sigma_v, rho, v0)\n  BCC2 = M76_char_func(u, T, lamb, mu, delta)\n  return BCC1 * BCC2\n\ndef H93_char_func(u, T, r, kappa_v, theta_v, sigma_v, rho, v0):\n  ''' Valuation of European call option in H93 model via Lewis (2001)\n  Fourier-based approach: characteristic function.\n  Parameter definitions see function BCC_call_value.'''\n  c1 = kappa_v * theta_v\n  c2 = -np.sqrt((rho * sigma_v * u * 1j - kappa_v)** 2 - sigma_v ** 2 * (-u * 1j - u ** 2))\n  c3 = (kappa_v - rho * sigma_v * u * 1j + c2) / (kappa_v - rho * sigma_v * u * 1j - c2)\n  H1 = (r * u * 1j * T + (c1 / sigma_v ** 2)* ((kappa_v - rho * sigma_v * u * 1j + c2) * T- 2 * np.log((1 - c3 * np.exp(c2 * T)) / (1 - c3))))\n  H2 = ((kappa_v - rho * sigma_v * u * 1j + c2) / sigma_v ** 2* ((1 - np.exp(c2 * T)) / (1 - c3 * np.exp(c2 * T))))\n  char_func_value = np.exp(H1 + H2 * v0)\n  return char_func_value\n\ndef M76_char_func(u, T, lamb, mu, delta):\n  ''' Valuation of European call option in M76 model via Lewis (2001)\n  Fourier-based approach: characteristic function.\n  Parameter definitions see function M76_call_value.'''\n  omega = -lamb * (np.exp(mu + 0.5 * delta ** 2) - 1)\n  char_func_value = np.exp((1j * u * omega + lamb * (np.exp(1j * u * mu - u ** 2 * delta ** 2 * 0.5) - 1)) * T)\n  return char_func_value\n\ndef M76_char_func_sa(u, T, r, sigma, lamb, mu, delta):\n  ''' Valuation of European call option in M76 model via Lewis (2001)\n  Fourier-based approach: characteristic function \"jump component\".\n  Parameter definitions see function M76_call_value.'''\n  omega = r - 0.5 * sigma ** 2 - lamb * (np.exp(mu + 0.5 * delta ** 2) - 1)\n  char_func_value = np.exp((1j * u * omega - 0.5 * u ** 2 * sigma ** 2+ lamb * (np.exp(1j * u * mu - u ** 2 * delta ** 2 * 0.5)- 1)) * T)\n  return char_func_value\n\nif __name__ == '__main__':\n  #\n  # Example Parameters CIR85 Model\n  #\n  kappa_r, theta_r, sigma_r, r0, T = 0.3, 0.04, 0.1, 0.04, T\n  B0T = B([kappa_r, theta_r, sigma_r, r0, T]) # discount factor\n  r = -np.log(B0T) / T\n  #\n  # Example Values\n  #\n  print(\"M76 Value %10.4f\" % M76_call_value(S0, K, T, r, v0, lamb, mu, delta))\n  print(\"H93 Value %10.4f\" % H93_call_value(S0, K, T, r, kappa_v, theta_v, sigma_v, rho, v0))\n  print(\"BCC97 Value %10.4f\" % BCC_call_value(S0, K, T, r, kappa_v, theta_v,sigma_v, rho, v0, lamb, mu, delta))## M76 Value     7.7611\n## H93 Value     6.8672\n## BCC97 Value     8.2942"}]
